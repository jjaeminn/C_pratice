#include <iostream> 
#include <limits>   
#include <string>   
#include <cstdlib>  
#include <cstring> 
#include <cmath> 

#define STACK_BASE 10
#define QUEUE_BASE 10 
#define MAX_TOKENS 50
#define MAX_TOKEN_LENGTH 20
#define MAX_EXPRESSION_LENGTH 100
#define MAX_HASH 16
using namespace std;

// 일단 주요 기능은 직접 짯고 범위 빠진 예외처리 정도만 구글링으로 찾음 
// Node 구조체
struct Node {
    int key;
    int value; 
    Node* next;// Node를 가리키는 next로 이 후값을 넣기 위해 정의 


    Node(int val) : key(val), value(val), next(nullptr) {} // 생성자로 데이터 초기화 
};




#define MAX_HASH 16
// 배열의 빈 슬롯을 나타낼 값 (0 이상의 키 값만 저장한다고 가정)
const int EMPTY_SLOT = -1;
// 삭제된 슬롯을 나타낼 값 (삭제 후 재삽입을 위한 처리)
const int DELETED_SLOT = -2;

class HashTable {
private:
    int* arr;       // 해시 테이블의 실제 배열 (동적 할당)
    int size;       // 배열의 현재 크기
    int count = 0;  // 현재 저장된 요소의 개수
    Node* head;
    Node* tail;
    Node** table;
    

public:
    // 생성자: 배열을 동적으로 할당하고 초기화
    HashTable(int initialSize = MAX_HASH) {
        if (initialSize <= 0) {
            std::cout << "오류: 해시 테이블 크기는 0보다 커야 합니다. 기본값 16으로 설정합니다." << std::endl;
            size = 16;
           
        }
        else {
            size = initialSize;
            table = new Node * [size]();
        }
        arr = new int[size];
        // 배열의 모든 칸을 EMPTY_SLOT으로 초기화
        for (int i = 0; i < size; ++i) {
            arr[i] = EMPTY_SLOT;
        }
    }

    // 소멸자: 할당된 메모리 해제
    ~HashTable() {
        delete[] arr;
        arr = nullptr;
    }

    bool isEmpty() const {
        return head == nullptr; // 또는 return size == 0;
    }


    // 각 버킷(인덱스)에 대한 pushBack 함수
 // head는 특정 버킷의 연결 리스트 시작점을 의미합니다.
    Node* pushBack(Node* head, int data) {
        Node* newNode = new Node(data);

        // 1. 리스트가 비어있는 경우 (head가 nullptr인 경우)
        if (head == nullptr) {
            return newNode; // 새 노드가 리스트의 첫 노드가 됩니다.
        }

        // 2. 리스트가 비어있지 않은 경우
        else {
            // 리스트의 맨 끝 노드를 찾기 위해 순회
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            // 맨 끝에 새 노드를 연결
            current->next = newNode;
            return head; // head는 변하지 않으므로 그대로 반환
        }
    }

    // Chaining 함수
    // 이 함수는 해시 테이블 클래스 안에 있다고 가정합니다.
    void chaining(int key) {
        int index = hash_function(key);
        table[index] = pushBack(table[index], key);
    }

    // 해시 함수: 키를 인덱스로 변환
    int hash_function(int key) {
        return key % size; // 테이블 크기를 기준으로 나눈 나머지 사용
    }



    // 리해싱(Rehashing): 배열이 가득 차면 크기를 2배로 확장하고 재배치
    void resize_table() {
        int oldSize = size;
        size *= 2;
        int* oldArr = arr;

        arr = new int[size];
        for (int i = 0; i < size; ++i) {
            arr[i] = EMPTY_SLOT;
        }

        // 이전 배열의 모든 요소를 새 배열로 재배치
        for (int i = 0; i < oldSize; ++i) {
            if (oldArr[i] != EMPTY_SLOT && oldArr[i] != DELETED_SLOT) {
                int key = oldArr[i];
                int index = find_slot(key);
                if (index != -1) { // -1이 아니면 슬롯을 찾음
                    arr[index] = key;
                }
            }
        }
        delete[] oldArr;
        std::cout << "해시 테이블 크기가 " << size << "로 확장되었습니다." << std::endl;
    }

    // 슬롯 찾기 함수: 삽입, 검색, 삭제 시 빈 칸이나 해당 키를 찾음
    // 인덱스를 반환하며, 찾지 못하면 -1 반환
    int find_slot(int key) {
        int start_index = hash_function(key);
        int index = start_index;

        // while 조건 수정: 해당 슬롯이 비어있지 않거나, 키 값이 일치하지 않을 때까지 순회
        while (arr[index] != EMPTY_SLOT) {
            if (arr[index] == key) {
                // 키를 찾았으면 해당 인덱스 반환
                return index;
            }
            // 선형 조사: 다음 칸으로 이동
            index = (index + 1) % size;
            if (index == start_index) {
                // 한 바퀴 돌았는데 찾지 못함 (테이블이 가득 찼거나, 키가 없음)
                return -1;
            }
        }
        // 비어있는 슬롯을 찾으면 해당 인덱스 반환
        return index;
    }

    // 삽입 함수
    bool set(int key) {
        // 로드 팩터(load factor)가 0.7 이상이면 테이블 확장
        if ((double)count / size >= 0.7) {
            resize_table();
        }

        int index = find_slot(key);

        if (index == -1) { // 테이블이 가득 차서 슬롯을 찾지 못함
            std::cout << "오류: 해시 테이블이 가득 차서 키를 삽입할 수 없습니다." << std::endl;
            return false;
        }

        if (arr[index] == key) { // 이미 같은 키가 존재하면 삽입 실패 (중복 방지)
            std::cout << "오류: 이미 같은 키가 존재합니다." << std::endl;
            return false;
        }

        arr[index] = key; // 키 삽입
        count++;
        return true;
    }

    // 삭제 함수
    bool remove(int key) {
        int index = find_slot(key);

        if (index == -1 || arr[index] == EMPTY_SLOT) {
            // 키를 찾지 못하거나 빈 슬롯이면 삭제 실패
            std::cout << "오류: 삭제하려는 키(" << key << ")가 존재하지 않습니다." << std::endl;
            return false;
        }

        arr[index] = DELETED_SLOT; // 삭제된 상태를 표시
        count--;
        return true;
    }

    // 키 존재 여부 확인 함수
    bool contains(int key) {
        int index = find_slot(key);
        return (index != -1 && arr[index] == key);
    }

    // 디버깅용: 테이블 내용 출력
    void printTable() {
        std::cout << "--- Hash Table Content ---" << std::endl;
        for (int i = 0; i < size; ++i) {
            std::cout << "Index [" << i << "]: ";
            if (arr[i] == EMPTY_SLOT) {
                std::cout << "EMPTY" << std::endl;
            }
            else if (arr[i] == DELETED_SLOT) {
                std::cout << "DELETED" << std::endl;
            }
            else {
                std::cout << arr[i] << std::endl;
            }
        }
        std::cout << "Current Size: " << size << ", Count: " << count << std::endl;
        std::cout << "--------------------------" << std::endl;
    }
};

int main() {
    HashTable myTable(5); // 크기 5의 해시 테이블 생성

    myTable.set(15); // 해시(15 % 5 = 0)
    myTable.set(5);  // 해시(5 % 5 = 0) -> 충돌 발생, 다음 칸으로 이동
    myTable.set(3);  // 해시(3 % 5 = 3)
    myTable.set(13); // 해시(13 % 5 = 3) -> 충돌 발생, 다음 칸으로 이동
    myTable.set(20); // 해시(20 % 5 = 0) -> 충돌 발생

    myTable.printTable();

    myTable.remove(5);
    myTable.printTable();

    // 삭제 후 검색
    if (myTable.contains(5)) {
        std::cout << "5가 테이블에 있습니다." << std::endl;
    }
    else {
        std::cout << "5는 테이블에 없습니다." << std::endl;
    }

    return 0;
}
