#include <iostream>
#include <vector>
#include <algorithm> 
using namespace std;

#define BASE_SIZE 16
class Node {
public:
    int key;
    int height = 1;
    Node* parent;
    Node* child_left;
    Node* child_right;
    Node* left;
    Node* right;
    

    Node(int k) : key(k), parent(nullptr), child_left(nullptr), child_right(nullptr),left(nullptr), right(nullptr) {}
};

class binary_tree {
private:
    int size;
    Node* root;

    // 재귀적 삽입을 위한 헬퍼 함수
    void insertNode(Node*& current, Node* newNode) {
        if (current == nullptr) { // 가장 위의 노드 root 
            current = newNode;
        }
        else if (newNode->key <= current->key) { // 왼쪽 노드에 놓기 
            insertNode(current->child_left, newNode);
            if (current->child_left) {
                current->child_left->parent = current;
            }
        }
        else { // newNode->key > current->key // 오른쪽 노드에 놓기 
            insertNode(current->child_right, newNode); 
            if (current->child_right) {
                current->child_right->parent = current;
            }
        }
    }

public:
    binary_tree() : root(nullptr), size(0) {}

    ~binary_tree() {
        // 모든 노드의 메모리를 해제하는 올바른 소멸자 로직이 필요합니다.
        // 일반적으로 재귀적인 후위 순회(post-order traversal)를 사용하여 구현합니다.
    }

    bool isEmpty() const {
        return size == 0;
    }

    void insert(int key) {
        Node* newNode = new Node(key);
        if (isEmpty()) {
            root = newNode;
            size++;
        }
        else {
            insertNode(root, newNode);
            size++;
        }
    }



    Node* find_node(int key) {
        Node* current = root;
        while (current != nullptr) {
            if (current->key == key) {
                // 키를 찾았으면 해당 노드를 반환하고 종료
                return current;
            }
            else if (current->key < key) {
                current = current->child_right;
            }
            else {
                current = current->child_left;
            }
        }
        // 루프가 끝날 때까지 키를 찾지 못했으면 nullptr 반환
        return nullptr;
    }

    Node* find_insertion_loc(int key) {
        if (isEmpty()) {
            return nullptr; // 트리가 비어있으면 부모가 없음
        }
        Node* parent = nullptr;
        Node* current = root;
        while (current != nullptr) {
            parent = current;
            if (current->key < key) {
                current = current->child_right;
            }
            else {
                current = current->child_left;
            }
        }
        return parent;
    }

    // Del_By_Merging: key를 가진 노드를 병합 방식으로 삭제
    int Del_By_Merging(int key) {
        // 1. 삭제할 노드 찾기
        Node* value = find_node(key);
        if (value == nullptr) {
            return -1; // 노드가 존재하지 않으면 -1 반환
        }

        Node* pt = value->parent;
        Node* value_left = value->child_left;
        Node* value_right = value->child_right;

        // 2. 자식 노드 유무에 따른 케이스 분리

        // case 1: 자식 노드가 없는 경우 (리프 노드)
        if (value_left == nullptr && value_right == nullptr) {
            if (pt == nullptr) { // 루트 노드인 경우
                root = nullptr;
            }
            else if (pt->child_left == value) { // 리프 노드에 왼쪽 노드 삭제 
                pt->child_left = nullptr;
            }
            else {
                pt->child_right = nullptr;// 리프 노드에 오른쪽 노드 삭제 
            }
            delete value;
            size--; // 삭제 후 size하나 삭제 
            return 0;
        }

        // case 2: 자식 노드가 하나만 있는 경우
        // 왼쪽 자식만 있는 경우
        if (value_right == nullptr) { //오른쪽 값이 없다면 
            if (pt == nullptr) { // 루트 노드인 경우
                root = value_left; // 
                value_left->parent = nullptr;
            }
            else if (pt->child_left == value) { // value의 왼쪽 지정 후 pt 연결 
                pt->child_left = value_left;
                value_left->parent = pt;
            }
            else {
                pt->child_right = value_left;
                value_left->parent = pt;
            }
            delete value;
            size--;
            return 0;
        }
        // 오른쪽 자식만 있는 경우
        if (value_left == nullptr) {
            if (pt == nullptr) { // 루트 노드인 경우
                root = value_right;
                value_right->parent = nullptr;
            }
            else if (pt->child_left == value) {
                pt->child_left = value_right;
                value_right->parent = pt;
            }
            else {
                pt->child_right = value_right;
                value_right->parent = pt;
            }
            delete value;
            size--;
            return 0;
        }

        // case 3: 자식 노드가 둘 다 있는 경우 (병합)
        // 3-1. 왼쪽 서브트리에서 가장 큰 값(가장 오른쪽 노드)을 찾기
        Node* max_in_left = value_left;
        while (max_in_left->child_right != nullptr) { // 왼쪽 중에서 가장 큰 것 찾기  
            max_in_left = max_in_left->child_right;  
        }

        // 3-2. 찾은 노드의 오른쪽에 오른쪽 서브트리를 연결
        max_in_left->child_right = value_right; 
        if (value_right != nullptr) {
            value_right->parent = max_in_left;
        }

        // 3-3. 부모 노드와 연결 변경
        if (pt == nullptr) { // 루트 노드인 경우
            root = value_left;
            root->parent = nullptr;
        }
        else if (pt->child_left == value) {
            pt->child_left = value_left;
            value_left->parent = pt;
        }
        else {
            pt->child_right = value_left;
            value_left->parent = pt;
        }

        delete value;
        size--;
        return 0;
    }
        


    int rotate_right(int key) {
        // 1. 회전할 노드(c)를 찾습니다.
        Node* c = find_node(key);
        if (c == nullptr || c->child_left == nullptr) {
            // c가 없거나, 왼쪽 자식이 없으면 회전할 수 없습니다.
            return -1;
        }

        // 2. 관계 설정
        Node* x = c->child_left;
        Node* b = x->child_right;
        Node* p = c->parent; // c의 부모를 p로 저장합니다.

        // 3. x를 c의 부모 자리에 연결합니다.
        x->parent = p;
        if (p == nullptr) { // c가 루트 노드일 경우
            root = x;
        }
        else if (p->child_left == c) { // 일단 x가 오른쪽으로 이동 
            p->child_left = x;
        }
        else {
            p->child_right = x;
        }

        // 4. c를 x의 오른쪽 자식으로 연결합니다.
        x->child_right = c; // C오른쪽으로 이동 
        c->parent = x; // C랑 X 연결 

        // 5. b를 c의 왼쪽 자식으로 연결합니다.
        c->child_left = b;
        if (b != nullptr) {
            b->parent = c;
        }

        return 0; // 회전 성공
    }



};


// 노드의 높이를 반환하는 함수 (nullptr인 경우 0 반환)
int getHeight(Node* node) {
    if (node == nullptr) { // nullptr까지 호출되고 리턴하면 높이가 나옴 -> 근데 아마 정확하게는 아니고 루트가 제외되기 때문에 정확한 값은 -1 해야함 
        return 0;
    }
    return node->height;
}

// 노드의 높이를 업데이트하는 함수
void updateHeight(Node* node) { // 왼쪽 or 오른쪽에서 더 치중된을 업데이트 
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));
}

// 노드의 균형 인수(Balance Factor)를 반환하는 함수
int getBalanceFactor(Node* node) { // 균형 함수가 절댓값 1을 넘으면 초과 됬다고 판단 
    if (node == nullptr) { 
        return 0;
    }
    return getHeight(node->left) - getHeight(node->right);
}

// --- 회전(Rotation) 함수들 ---
// 회전 함수들은 이전에 설명된 로직을 따릅니다.

Node* rotateRight(Node* c) {
    Node* x = c->left;
    Node* b = x->right;

    // 회전
    x->right = c;
    c->left = b;

    // 높이 업데이트 (c 먼저, 그 다음 x)
    updateHeight(c);
    updateHeight(x);

    return x;
}

Node* rotateLeft(Node* p) {
    Node* q = p->right;
    Node* b = q->left;

    // 회전
    q->left = p;
    p->right = b;

    // 높이 업데이트 (p 먼저, 그 다음 q)
    updateHeight(p);
    updateHeight(q);

    return q;
}

// --- AVL 트리 삭제 함수 ---
Node* deleteNode(Node* root, int key) {
    // 1. 일반 BST 삭제 로직
    if (root == nullptr) {
        return root;
    }

    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    }
    else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    }
    else { // 삭제할 노드를 찾았을 경우
        // 자식 노드가 0개 또는 1개
        if (root->left == nullptr || root->right == nullptr) {
            Node* temp = root->left ? root->left : root->right;
            if (temp == nullptr) { // 자식 노드가 없는 경우
                temp = root; // root올리고 temp 삭제 
                root = nullptr;
            }
            else { // 자식 노드가 1개 있는 경우 -> root에 올리기 temp 삭제 
                *root = *temp;
            }
            delete temp;
        }
        else { // 자식 노드가 2개 있는 경우
            // 오른쪽 서브트리에서 가장 작은 값을 가진 노드(후계자)를 찾음
            Node* temp = root->right; // 오른쪽으로 한칸이동 
            while (temp->left != nullptr) {
                temp = temp->left; // 오른쪽 부트리의 왼쪽 끝까지 이동 
            }
            // 후계자 노드의 값을 현재 노드에 복사
            root->key = temp->key;
            // 후계자 노드를 삭제
            root->right = deleteNode(root->right, temp->key); // 그것을 삭제 
        }
    }

    // 루트 노드가 nullptr이 될 수 있으므로 여기서 처리
    if (root == nullptr) {
        return root;
    }

    // 2. 현재 노드의 높이 업데이트
    updateHeight(root);

    // 3. 현재 노드의 균형 인수 계산
    int balance = getBalanceFactor(root);

    // 4. 균형이 깨졌다면 회전으로 균형 맞추기
    // Left Left Case (LL)
    if (balance > 1 && getBalanceFactor(root->left) >= 0) {
        return rotateRight(root);
    }
    // Left Right Case (LR)
    if (balance > 1 && getBalanceFactor(root->left) < 0) {
        root->left = rotateLeft(root->left);
        return rotateRight(root);
    }
    // Right Right Case (RR)
    if (balance < -1 && getBalanceFactor(root->right) <= 0) {
        return rotateLeft(root);
    }
    // Right Left Case (RL)
    if (balance < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rotateRight(root->right);
        return rotateLeft(root);
    }

    return root;
}

// 전역 변수 대신 배열을 함수 인자로 전달
// 힙의 크기를 알아야 하므로 length도 인자로 받음
bool is_leaf_node(int parent_index, int length) {
    int left_child_index = 2 * parent_index + 1;
    return left_child_index >= length; // 오른쪽 자식 노드가 존재한다면 반드시 왼쪽 자식 노드도 존재 <(대우)> 왼쪽 자식 노드가 존재하지 않는다면 오른쪽 자식의 노드 존재 X 
 // 즉 자식의 왼쪽 노드가 배열의 범위를 벗어나면 오른쪽 노드도 없다는거니까 가장 마지막 노드로 판별 = 리프노드 
}
int find_max_index_from_children(const std::vector<int>& arr, int parent_index, int length) { // 매개변수는 vector을 이용해서 arr 가져오고 0으로 초기화 , 부모 인덱스, 원소 갯수 받기 
    
    int left_child_index = 2 * parent_index + 1; // 왼쪽 자식 노드 
    int right_child_index = 2 * parent_index + 2;// 오른쪽 자식 노드 
    int largest_index = parent_index;

    if (left_child_index < length && arr[left_child_index] > arr[largest_index]) { // 리프노드가 아니고 left 노드가 가장 크면 
        largest_index = left_child_index;
    }

    // 오른쪽 자식 노드가 존재하고, 현재 largest_index의 값보다 크면 업데이트
    if (right_child_index < length && arr[right_child_index] > arr[largest_index]) { // 리프노드가 아니고 right 노드가 가장 크면 
        largest_index = right_child_index;
    }

    return largest_index;
}
void heapify_down(vector<int>& arr, int parent_index, int length) {
    while (!is_leaf_node(parent_index, length)) {
        int largest_index = find_max_index_from_children(arr, parent_index, length);

        // 부모가 가장 큰 값이 아니면, 자식과 교환하고 계속 아래로 내려감
        if (largest_index != parent_index) {
            swap(arr[parent_index], arr[largest_index]);
            parent_index = largest_index; // 다음 루프를 위해 인덱스 업데이트
        }
        else {
            // 부모가 가장 크면 힙 속성이 만족되므로 루프 종료
            break;
        }
    }
}
void heapify_up(vector<int>& arr) {
    // 힙에 새롭게 추가된 요소의 인덱스를 현재(자식) 인덱스로 설정
    int current_child_index = arr.size() - 1;

    // 루트 노드(인덱스 0)에 도달할 때까지 반복
    while (current_child_index > 0) {
        // 부모 노드의 인덱스 계산
        int parent_index = (current_child_index - 1) / 2;

        // 현재 노드의 값이 부모 노드의 값보다 크면 (최대 힙 기준)
        if (arr[current_child_index] > arr[parent_index]) {
            // 부모와 자식의 위치를 바꿈
           swap(arr[current_child_index], arr[parent_index]);

            // 현재 노드 위치를 부모 노드의 위치로 업데이트하여 다음 반복 준비
            current_child_index = parent_index;
        }
        else {
            // 부모가 더 크거나 같으면 이미 힙 속성이 만족되므로 종료
            break;
        }
    }
}
int del_max(vector<int>& arr) {
    if (arr.empty()) {
        cout << "뺄 값이 없음" << endl;
        return -1;
    }

    int max_value = arr[0];// 루트값 빼기 
    arr[0] = arr.back();
    arr.pop_back();
    if (arr.size() > 1) {
        heapify_down(arr, 0, arr.size()); // 재정렬 
    }
    return max_value;
}
void make_heap(vector<int>& arr) {
    int length = arr.size();
    // 리프 노드의 부모 노드부터 시작하여 역순으로 힙 다운 수행
    for (int i = (length / 2) - 1; i >= 0; --i) { // 부모 노드 부터 
        heapify_down(arr, i, length);
    }
   cout << "make-heap 완료" << endl;
}




int main() {
    vector<int> arr = { 1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17 };

    cout << "Original array: ";
    for (int val : arr) {
        cout << val << " ";
    }
    cout << std::endl;

    make_heap(arr);

    cout << "Max-Heap array: ";
    for (int val : arr) {
        cout << val << " ";
    }
    cout << std::endl;

    return 0;
}

