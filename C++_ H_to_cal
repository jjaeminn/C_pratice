#include <iostream> 
#include <limits>   
#include <string>   
#include <cstdlib>  
#include <cstring> 
#include <utility> 

#define STACK_BASE 10
#define QUEUE_BASE 10 
#define MAX_TOKENS 50
#define MAX_TOKEN_LENGTH 20
#define MAX_EXPRESSION_LENGTH 100
using namespace std;

// 일단 주요 기능은 직접 짯고 범위 빠진 예외처리 정도만 구글링으로 찾음 
// Node 구조체
struct Node {
    int data;
    Node* prev;
    Node* next;


    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// 주요 stack에서 일어나는 함수들 모음 
class stack {
private:
    int top;
    int capacity;
    int* arr;

public:
    // 생성자: 스택의 초기 크기를 설정하고 메모리를 할당합니다.
    // initialSize가 0 이하이면 기본값 10으로 설정합니다.
    stack(int initialSize = STACK_BASE) { // 기본값 STACK_BASE에서 수정 가능 
        if (initialSize <= 0) {
            cout << "오류: 스택 크기는 0보다 커야 합니다. 기본값 10으로 설정합니다." << endl;
            capacity = 10;
        }
        else {
            capacity = initialSize;
        }
        arr = new int[capacity];
        top = -1;
    }

    // 소멸자: 할당된 메모리를 해제합니다.
    ~stack() {
        delete[] arr;
        arr = nullptr;
    }

    // Push: 스택에 데이터를 추가합니다.
    void Push(int data) {
        if (top == capacity - 1) {
            // cout << "오류: 스택이 가득 찼습니다. (" << data << "를 넣을 수 없습니다.)" << endl;
            return;
        }
        top++; // 값의 상위값을 추척 
        arr[top] = data; // 데이터를 배열에 저장 
        // cout << data << "를 스택에 넣었습니다. (현재 top: " << top << ")" << endl;
    }

    // Pop: 스택에서 데이터를 제거하고 반환합니다.
    int Pop() {
        if (top == -1) {
            // cout << "오류: 스택이 비어있습니다. 뺄 값이 없습니다." << endl;
            return numeric_limits<int>::min(); // 스택이 비어있을 때 오류 값 반환
        }
        int popped_value = arr[top];
        top--; // 제거되니까 한 단계 -1 
        // cout << popped_value << " 값을 스택에서 뺐습니다. (현재 top: " << top << ")" << endl;
        return popped_value;
    }

    // isEmpty: 스택이 비어있는지 확인합니다.
    bool isEmpty() const { 
        return top == -1;
    }

    // isFull: 스택이 가득 찼는지 확인합니다.
    bool isFull() const {
        return top == capacity - 1;
    }

    // peek: 스택의 최상단 값을 확인합니다 (제거하지 않음).
    int peek() const {
        if (top == -1) {
            // cout << "오류: 스택이 비어있습니다. 최상단 값을 가져올 수 없습니다." << endl;
            return std::numeric_limits<int>::min(); // 스택이 비어있을 때 오류 값 반환
        }
        return arr[top];
    }
}; 

// 주요 Queue에서 일어나는 함수들 모음 
class Queue { // 클래스 이름 변경 제안
private:
    int front;          // 큐의 맨 앞 요소 인덱스
    int rear;           // 큐의 맨 뒤 요소 인덱스
    int capacity;       // 큐의 최대 크기
    int currentSize;    // 큐에 현재 들어있는 요소의 개수
    int* arr;           // 요소를 저장할 동적 배열

public:
    // 생성자
    Queue(int initialSize = QUEUE_BASE) { // QUEUE_BASE 사용
        if (initialSize <= 0) {
            std::cout << "오류: 큐 크기는 0보다 커야합니다. 기본값을 10으로 설정합니다." << std::endl;
            capacity = 10;
        }
        else {
            capacity = initialSize;
        }
        arr = new int[capacity];
        front = -1;     // 빈 큐를 나타냄
        rear = -1;      // 빈 큐를 나타냄
        currentSize = 0;
    }

    // 소멸자
    ~Queue() {
        delete[] arr;
        arr = nullptr;
    }

    // enqueue: 큐의 맨 뒤에 요소를 추가합니다.
    void enqueue(int data) {
        if (isFull()) {
            std::cout << "큐가 가득 찼습니다. " << data << "를 추가할 수 없습니다." << std::endl;
            return;
        }


        if (isEmpty()) {
            front = 0;
            rear = 0;
        }
        else {
            rear = (rear + 1) % capacity;
        }

        arr[rear] = data;
        currentSize++;
        std::cout << data << "가 큐에 추가되었습니다. (현재 크기: " << currentSize << ")" << std::endl;
    }


    int dequeue() {
        if (isEmpty()) {
            std::cout << "큐가 비어 있습니다. 제거할 요소가 없습니다." << std::endl;
            return -1; // 또는 예외를 던질 수 있습니다.
        }

        int dequeued_value = arr[front]; // 값을 먼저 저장

        // 마지막 요소가 제거될 경우 큐를 빈 상태로 초기화
        if (currentSize == 1) { // front == rear 일 때, 즉 요소가 하나 남았을 때
            front = -1;
            rear = -1;
        }
        else {
            front = (front + 1) % capacity; // 원형 배열처럼 동작하도록 모듈로 연산 사용
        }
        currentSize--;
        cout << dequeued_value << "가 큐에서 제거되었습니다. (현재 크기: " << currentSize << ")" << std::endl;
        return dequeued_value;
    }

    // peek: 큐의 맨 앞 요소를 제거하지 않고 반환합니다.
    int peek() const {
        if (isEmpty()) {
            std::cout << "큐가 비어 있습니다. 확인할 요소가 없습니다." << std::endl;
            return -1; // 또는 예외를 던질 수 있습니다.
        }
        return arr[front];
    }

    // isEmpty: 큐가 비어있는지 확인합니다.
    bool isEmpty() const {
        return currentSize == 0;
    }

    // isFull: 큐가 가득 찼는지 확인합니다.
    bool isFull() const {
        return currentSize == capacity;
    }

    // getCurrentSize: 큐에 현재 들어있는 요소의 개수를 반환합니다.
    int getCurrentSize() const {
        return currentSize;
    }
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
    Node* first;
    Node* final;
    int size;


public:

    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}


    ~DoublyLinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* nextNode = current->next;
            delete current;
            current = nextNode;
        }
        head = nullptr;
        tail = nullptr;
        size = 0;
    }

    // isEmpty: 큐가 비어있는지 확인합니다. (멤버 변수를 수정하지 않으므로 const 사용)
    bool isEmpty() const {
        return head == nullptr; // 또는 return size == 0;
    }

    // pushBack: 리스트의 뒤쪽에 새 노드를 추가합니다.
    void pushBack(int data) {
        Node* newNode = new Node(data);

        // 1. 리스트가 비어있는 경우 (첫 노드를 추가하는 경우)
        if (isEmpty()) {
            head = newNode;
            tail = newNode;

        }
        // 2. 리스트가 비어있지 않은 경우 (기존 노드 뒤에 추가하는 경우)
        else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
        size++; // 리스트의 크기 증가
        cout << data << "가 리스트 뒤에 추가되었습니다. (현재 크기: " << size << ")" << endl;
    }

    int popFront() {
        if (isEmpty()) {
            return -1;
        }

        if (head == tail) { // 또는 size == 1로 검사해도 됩니다.
            head = nullptr;
            tail = nullptr;
        }
        Node* popNode = head; // pop할 노드 Head로 설정 
        int popdata = popNode->data;
        head = head->next;
        head->prev = nullptr;
        delete popNode;
        size--;
        return popdata;
    }


    int popBack() {
        if (isEmpty()) {
            return -1;
        }

        if (head == tail) { // 또는 size == 1로 검사해도 됩니다.
            head = nullptr;
            tail = nullptr;
        }

        Node* popNode = tail; // pop할 노드 tail로 설정 
        int popdata_tail = popNode->data;

        tail = tail->prev; //tail 삭제로 인한 뒤로 이동
        tail->next = nullptr;
        delete popNode;
        size--;
        return popdata_tail;

    }

   

    std::pair<Node*, int> Search(int targetData) const {
        if (isEmpty()) {
            return { nullptr, -1 };
        }

        Node* current = head;
        int index = 0;

        while (current != nullptr) {
            if (current->data == targetData) {
                return { current, index };
            }
            current = current->next;
            index++;
        }
        return { nullptr, -1 };
    }

    void Splice(int a_val, int b_val, int x_val) {
        Node* X = new Node(x_val);

        std::pair<Node*, int> a_result = Search(a_val);
        Node* startNode = a_result.first;
        int startIndex = a_result.second;

        std::pair<Node*, int> b_result = Search(b_val);
        Node* endNode = b_result.first;
        int endIndex = b_result.second;

        if (startNode == nullptr) {
            std::cout << "오류: 시작 노드(" << a_val << ")를 리스트에서 찾을 수 없습니다. Splice 작업을 중단합니다." << std::endl;
            delete X;
            return;
        }
        if (endNode == nullptr) {
            std::cout << "오류: 끝 노드(" << b_val << ")를 리스트에서 찾을 수 없습니다. Splice 작업을 중단합니다." << std::endl;
            delete X;
            return;
        }

        if (startIndex > endIndex) {
            std::cout << "오류: 시작 노드(" << a_val << ")가 끝 노드(" << b_val << ")보다 뒤에 있습니다. 유효하지 않은 범위입니다. Splice 작업을 중단합니다." << std::endl;
            delete X;
            return;
        }

        Node* nodeBeforeStart = startNode->prev;
        Node* nodeAfterEnd = endNode->next;

        Node* currentToDelete = startNode;
        int nodesRemovedCount = 0;
        while (currentToDelete != nodeAfterEnd) {
            Node* nextToDelete = currentToDelete->next;
            delete currentToDelete;
            currentToDelete = nextToDelete;
            nodesRemovedCount++;
        }

        X->prev = nodeBeforeStart;
        X->next = nodeAfterEnd;

        if (nodeBeforeStart != nullptr) {
            nodeBeforeStart->next = X;
        }
        else {
            head = X;
        }

        if (nodeAfterEnd != nullptr) {
            nodeAfterEnd->prev = X;
        }
        else {
            tail = X;
        }

        size = size - nodesRemovedCount + 1;
        std::cout << "Splice 작업이 완료되었습니다: " << a_val << "부터 " << b_val << "까지의 노드가 제거되고 " << x_val << "이(가) 삽입되었습니다." << std::endl;
    }

    void insertAfter(int targetVal, int insertVal) {
        std::pair<Node*, int> targetResult = Search(targetVal);
        Node* targetNode = targetResult.first;

        if (targetNode == nullptr) {
            std::cout << "오류: " << targetVal << "을(를) 찾을 수 없어 뒤에 삽입할 수 없습니다." << std::endl;
            return;
        }

        Node* newNode = new Node(insertVal);

        newNode->next = targetNode->next;
        newNode->prev = targetNode;

        if (targetNode->next != nullptr) {
            targetNode->next->prev = newNode;
        }
        else {
            tail = newNode;
        }
        targetNode->next = newNode;

        size++;
        std::cout << insertVal << "가 " << targetVal << " 뒤에 삽입되었습니다." << std::endl;
    }

    void remove(int targetVal) {
        std::pair<Node*, int> targetResult = Search(targetVal);
        Node* targetNode = targetResult.first;

        if (targetNode == nullptr) {
            std::cout << "오류: " << targetVal << "을(를) 찾을 수 없어 제거할 수 없습니다." << std::endl;
            return;
        }

        if (targetNode == head) {
            popFront();
            return;
        }
        if (targetNode == tail) {
            popBack();
            return;
        }

        targetNode->prev->next = targetNode->next;
        targetNode->next->prev = targetNode->prev;

        delete targetNode;
        size--;
        std::cout << targetVal << "이(가) 리스트에서 제거되었습니다." << std::endl;
    }

    void displayForward() const {
        if (isEmpty()) {
            cout << "리스트가 비어있습니다." << endl;
            return;
        }
        Node* current = head;
        cout << "리스트 (앞 -> 뒤): ";
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }

    // 리스트 내용을 뒤에서부터 출력 (디버깅용)
    void displayBackward() const {
        if (isEmpty()) {
            cout << "리스트가 비어있습니다." << endl;
            return;
        }
        Node* current = tail;
        std::cout << "리스트 (뒤 -> 앞): ";
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->prev;
        }
        cout << endl;
    }




};

// 문자가 숫자인지 확인하는 헬퍼 함수
bool isDigitCustom(char ch) {
    return (ch >= '0' && ch <= '9');
}

// 문자가 연산자 또는 괄호인지 확인하는 헬퍼 함수
bool isOperatorOrParenthesis(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '(' || ch == ')');
}

// 연산자의 우선순위를 반환하는 함수
// 숫자가 높을수록 우선순위가 높습니다.
int getOperatorPrecedence(char op) {
    if (op == '+' || op == '-') { // 우선순위를 정수로 리턴해서 나중에 비교 할 때 정수로 순위 결정 
        return 1;
    }
    if (op == '*' || op == '/') {
        return 2;
    }
    return 0; // 괄호나 다른 문자 (최하위 우선순위)
}

// op1이 op2보다 우선순위가 높거나 같으면 true를 반환
bool hasHigherPrecedence(char op1, char op2) {
    return getOperatorPrecedence(op1) >= getOperatorPrecedence(op2);
}

// 값들 토큰화 
int tokenizeExpressionNoLib(const char* expression, char tokenArray[MAX_TOKENS][MAX_TOKEN_LENGTH]) { // 문자열의 1번째 값과, 저장할 2차원 배열을 받는다. 
    int tokenCount = 0;
    int exprIndex = 0; // 현재 수식 문자열의 인덱스

    while (expression[exprIndex] != '\0') { // 문자열 끝까지 순회
        // 1. 공백 무시
        if (expression[exprIndex] == ' ' || expression[exprIndex] == '\t' || expression[exprIndex] == '\n') {
            exprIndex++; // tokencount는 안하지만 그래도 수식 문자열은++ 
            continue;
        }

        // 2. 연산자 또는 괄호 처리
        if (isOperatorOrParenthesis(expression[exprIndex])) {
            if (tokenCount >= MAX_TOKENS) {
                cout << "오류: 토큰 배열이 가득 찼습니다." << endl;
                return -1;
            }
            tokenArray[tokenCount][0] = expression[exprIndex]; // [0~N][0]은 연산자를 놓기 
            tokenArray[tokenCount][1] = '\0'; // 널 종료 문자 추가 [0~N][1]을 놓어서 [0~N][0]이 다 순회하면 자동으로 '\0' 값 반환으로 종료 
            tokenCount++;
            exprIndex++;
            continue;
        }

        // 3. 숫자 (정수 또는 실수) 처리
        if (isDigitCustom(expression[exprIndex])) {
            if (tokenCount >= MAX_TOKENS) {
                cout << "오류: 토큰 배열이 가득 찼습니다." << endl;
                return -1;
            }
            int tokenCharIndex = 0;
            bool hasDecimal = false;

            // 숫자가 아닐 때까지 또는 문자열 끝까지 읽기
            while (expression[exprIndex] != '\0' && (isDigitCustom(expression[exprIndex]) || expression[exprIndex] == '.')) {
                if (tokenCharIndex >= MAX_TOKEN_LENGTH - 1) { // 토큰 길이 초과 방지
                    cout << "오류: 토큰 길이가 너무 깁니다." << endl;
                    return -1;
                }
                if (expression[exprIndex] == '.') {
                    if (hasDecimal) {
                        cout << "오류: 잘못된 숫자 형식 (소수점 중복)." << endl;
                        return -1;
                    }
                    hasDecimal = true;
                }
                tokenArray[tokenCount][tokenCharIndex] = expression[exprIndex];
                tokenCharIndex++;
                exprIndex++;
            }
            tokenArray[tokenCount][tokenCharIndex] = '\0'; // 널 종료 문자 추가
            tokenCount++;
            continue;
        }

        // 4. 알 수 없는 문자 처리 (오류)
        cout << "오류: 알 수 없는 문자 발견 - '" << expression[exprIndex] << "'" << endl;
        return -1;
    }

    return tokenCount;
}

// 중위 표기식 토큰을 후위 표기식 토큰으로 변환하는 함수 
// tokenArray: 중위 표기식 토큰 배열
// numTokens: 중위 표기식 토큰의 개수
// postfixTokens: 변환된 후위 표기식 토큰이 저장될 배열 (출력 매개변수)
// 반환 값: 후위 표기식 토큰의 개수, 오류 시 -1
// 즉 infix -> Postfix로 재정리
int infixToPostfix(char tokenArray[MAX_TOKENS][MAX_TOKEN_LENGTH], int numTokens, char postfixTokens[MAX_TOKENS][MAX_TOKEN_LENGTH]) {
    stack operatorStack(MAX_TOKENS); // 연산자를 위한 스택
    int postfixCount = 0;

    for (int i = 0; i < numTokens; ++i) {
        char* token = tokenArray[i];

        // 1. 숫자인 경우: 바로 후위 표기식으로 출력
        // strtod를 사용하여 숫자인지 가장 정확하게 판별
        char* endPtr;
        strtod(token, &endPtr); // 변환 시도 (값은 사용하지 않고 숫자 여부만 판단)

        // endPtr이 널 문자를 가리키고, 토큰이 비어있지 않으면 유효한 숫자
        if (endPtr[0] == '\0' && strlen(token) > 0) {
            if (postfixCount >= MAX_TOKENS) return -1; // 배열 오버플로우
            strcpy_s(postfixTokens[postfixCount], token); // 들어있는 거 읽기 
            postfixCount++;
        }
        // 2. 여는 괄호인 경우: 스택에 푸시
        else if (token[0] == '(' && strlen(token) == 1) { // 우선순위 2번째 or '(' 
            operatorStack.Push('(');
        }
        // 3. 닫는 괄호인 경우: 여는 괄호가 나올 때까지 스택에서 팝하여 후위 표기식으로 추가
        else if (token[0] == ')' && strlen(token) == 1) {
            while (!operatorStack.isEmpty() && operatorStack.peek() != '(') {
                if (postfixCount >= MAX_TOKENS) return -1;
                postfixTokens[postfixCount][0] = static_cast<char>(operatorStack.Pop()); 
                postfixTokens[postfixCount][1] = '\0';
                postfixCount++;
            }
            if (!operatorStack.isEmpty() && operatorStack.peek() == '(') { // 괄호 나오면 팝하여 버림 
                operatorStack.Pop(); // 여는 괄호 '(' 팝하여 버림
            }
            else {
                cout << "오류: 괄호 불일치 - 닫는 괄호에 짝이 없습니다." << endl;
                return -1; // 괄호 불일치 오류
            }
        }
        // 4. 연산자인 경우:
        else if (isOperatorOrParenthesis(token[0]) && strlen(token) == 1) {
            while (!operatorStack.isEmpty() && operatorStack.peek() != '(' && hasHigherPrecedence(static_cast<char>(operatorStack.peek()), token[0])) { // 안비어있고, 상위에 '(' 없고, 연산자가 현재 연산자보다 우선순위가 높으면 
                if (postfixCount >= MAX_TOKENS) return -1;
                postfixTokens[postfixCount][0] = static_cast<char>(operatorStack.Pop()); // 그걸 Poo해서 
                postfixTokens[postfixCount][1] = '\0';
                postfixCount++;
            }
            operatorStack.Push(token[0]); // 우선순위에 따라 쭉 올라가거나 내려감 
        }
        // 5. 알 수 없는 토큰
        else {
            cout << "오류: infixToPostfix - 알 수 없는 토큰 '" << token << "'" << endl;
            return -1;
        }
    }

    // 스택에 남아있는 모든 연산자를 후위 표기식으로 추가
    while (!operatorStack.isEmpty()) {
        if (operatorStack.peek() == '(' || operatorStack.peek() == ')') {
            cout << "오류: 괄호 불일치 - 여는 괄호가 짝이 없습니다." << endl;
            return -1; // 괄호 불일치 오류
        }
        if (postfixCount >= MAX_TOKENS) return -1;
        postfixTokens[postfixCount][0] = static_cast<char>(operatorStack.Pop());
        postfixTokens[postfixCount][1] = '\0';
        postfixCount++;
    }

    return postfixCount;
}

// 후위 표기식을 계산하는 함수
// postfixTokens: 후위 표기식 토큰 배열
// numPostfixTokens: 후위 표기식 토큰의 개수
// 반환 값: 계산 결과 (double), 오류 시 numeric_limits<double>quiet_NaN() 등 반환
// 즉 계산
double evaluatePostfix(char postfixTokens[MAX_TOKENS][MAX_TOKEN_LENGTH], int numPostfixTokens) {
    stack operandStack(MAX_TOKENS); // 피연산자(숫자)를 위한 스택

    for (int i = 0; i < numPostfixTokens; ++i) {
        char* token = postfixTokens[i];

        // 1. 숫자인 경우: 스택에 푸시
        char* endPtr;
        double value = strtod(token, &endPtr); // 문자열을 double로 변환 시도

        // 변환 성공 (endPtr이 널 문자 '\0'를 가리키면 전체 문자열이 숫자로 변환됨)
        // 그리고 token이 비어있지 않은지도 확인
        if (endPtr[0] == '\0' && strlen(token) > 0) {
            // stack 클래스가 int만 저장하므로, double을 int로 변환하여 푸시합니다.
            // **주의: 정밀도 손실이 발생할 수 있습니다!**
            // 실제로는 double을 저장할 수 있는 스택을 새로 만드는 것이 좋습니다.
            operandStack.Push(static_cast<int>(value));
        }
        // 2. 연산자인 경우: 스택에서 두 개의 피연산자를 팝하여 계산 후 결과 푸시
        else if (isOperatorOrParenthesis(token[0]) && strlen(token) == 1) { // 한 글자 연산자인지 확인
            if (operandStack.isEmpty()) {
                cout << "오류: 후위 표기식 계산 - 연산자에 필요한 피연산자가 부족합니다." << endl;
                return numeric_limits<double>::quiet_NaN(); // Not a Number
            }
            double operand2 = static_cast<double>(operandStack.Pop()); // 두 번째 피연산자
            if (operandStack.isEmpty()) {
                cout << "오류: 후위 표기식 계산 - 연산자에 필요한 피연산자가 부족합니다." << endl;
                return numeric_limits<double>::quiet_NaN();
            }
            double operand1 = static_cast<double>(operandStack.Pop()); // 첫 번째 피연산자
            double result = 0.0;

            switch (token[0]) {
            case '+': result = operand1 + operand2; break;
            case '-': result = operand1 - operand2; break;
            case '*': result = operand1 * operand2; break;
            case '/':
                if (operand2 == 0) {
                    cout << "오류: 0으로 나눌 수 없습니다." << endl;
                    return std::numeric_limits<double>::infinity(); // 무한대 반환
                }
                result = operand1 / operand2;
                break;
            default:
                cout << "오류: 후위 표기식 계산 - 알 수 없는 연산자 '" << token[0] << "'" << endl;
                return std::numeric_limits<double>::quiet_NaN();
            }
            operandStack.Push(static_cast<int>(result)); // 결과를 다시 스택에 푸시 (정밀도 손실)
        }
        else {
            cout << "오류: 후위 표기식 계산 - 유효하지 않은 토큰 '" << token << "'" << endl;
            return std::numeric_limits<double>::quiet_NaN();
        }
    }

    if (operandStack.isEmpty()) {
        cout << "오류: 후위 표기식 계산 - 스택에 최종 결과가 없습니다." << endl;
        return std::numeric_limits<double>::quiet_NaN();
    }
    // 스택에 최종적으로 하나의 값만 남아있는지 확인 (top이 0이어야 함)
    // top이 -1에서 시작하므로, 0이면 한 개의 요소가 남아있다는 의미
   


    return static_cast<double>(operandStack.Pop()); // 최종 결과 반환
}



int main() {
   


    return 0; 
}
